"""
Markdown report generator implementation
"""
from typing import List, Dict
from datetime import datetime
from collections import Counter

from ...domain.ports.report_generator import ReportGeneratorPort
from ...domain.models.report import (
    MarkdownReport,
    ReportMetadata,
    IssueSummary,
    ReportStatistics
)


class MarkdownReportGenerator(ReportGeneratorPort):
    """Generate markdown reports from IMS issues"""

    def generate_markdown(
        self,
        metadata: ReportMetadata,
        issues: List[IssueSummary]
    ) -> MarkdownReport:
        """Generate complete markdown report"""

        statistics = self._calculate_statistics(issues)

        sections = [
            self._generate_header(metadata),
            self._generate_metadata_section(metadata),
            self.generate_statistics_section(issues),
            self.generate_summary_charts(issues),
            self._generate_detailed_issues_section(issues),
            self._generate_footer()
        ]

        markdown_content = "\n\n".join(sections)

        return MarkdownReport(
            metadata=metadata,
            statistics=statistics,
            issues=issues,
            markdown_content=markdown_content
        )

    def _generate_header(self, metadata: ReportMetadata) -> str:
        """Generate report header"""
        return f"""# {metadata.title}
Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""

    def _generate_metadata_section(self, metadata: ReportMetadata) -> str:
        """Generate metadata section"""
        return f"""## Report Metadata
- **Query**: {metadata.query}
- **Strategy**: {metadata.strategy}
- **Total Issues**: {metadata.total_issues}
"""

    def generate_statistics_section(self, issues: List[IssueSummary]) -> str:
        """Generate statistics section"""
        stats = self._calculate_statistics(issues)
        
        status_counts = "\n".join([f"- {s}: {c}" for s, c in stats.status_distribution.items()])
        priority_counts = "\n".join([f"- {p}: {c}" for p, c in stats.priority_distribution.items()])
        
        return f"""## Statistics
### Status Distribution
{status_counts}

### Priority Distribution
{priority_counts}
"""

    def generate_summary_charts(self, issues: List[IssueSummary]) -> str:
        """Generate Mermaid charts for the report"""
        stats = self._calculate_statistics(issues)
        
        # Status Pie Chart
        status_data = "\n".join([f'    "{s}" : {c}' for s, c in stats.status_distribution.items()])
        
        # Priority Bar Chart
        priority_data = "\n".join([f'    "{p}" : {c}' for p, c in stats.priority_distribution.items()])
        
        return f"""## Visual Summary
### Status Breakdown
```mermaid
pie title Issue Status
{status_data}
```

### Priority Breakdown
```mermaid
xychart-beta
    title "Issue Priority"
    x-axis [{", ".join([f'"{p}"' for p in stats.priority_distribution.keys()])}]
    y-axis "Count"
    bar [{", ".join([str(c) for c in stats.priority_distribution.values()])}]
```
"""

    def _generate_detailed_issues_section(self, issues: List[IssueSummary]) -> str:
        """Generate detailed issues section"""
        issue_rows = []
        for issue in issues:
            issue_rows.append(f"""### [{issue.ims_id}] {issue.title}
- **Status**: {issue.status}
- **Priority**: {issue.priority}
- **Reporter**: {issue.reporter}
- **Created**: {issue.created_at.strftime('%Y-%m-%d')}

#### Description
{issue.description}

---
""")
        
        return "## Detailed Issues\n" + "\n".join(issue_rows)

    def _generate_footer(self) -> str:
        """Generate report footer"""
        return f"""
---
*This report was automatically generated by IMS Crawler.*
"""

    def _calculate_statistics(self, issues: List[IssueSummary]) -> ReportStatistics:
        """Calculate statistics from issues"""
        if not issues:
            return ReportStatistics(
                total_count=0,
                status_distribution={},
                priority_distribution={},
                reporter_distribution={},
                average_resolution_time=0.0
            )
            
        status_dist = dict(Counter([i.status for i in issues]))
        priority_dist = dict(Counter([i.priority for i in issues]))
        reporter_dist = dict(Counter([i.reporter for i in issues]))
        
        return ReportStatistics(
            total_count=len(issues),
            status_distribution=status_dist,
            priority_distribution=priority_dist,
            reporter_distribution=reporter_dist,
            average_resolution_time=0.0  # Not implemented
        )
